{"ast":null,"code":"'use strict';\n/** Highest positive signed 32-bit float value */\n\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\n\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\n\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\n\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\n\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\n\nconst errors = {\n  'overflow': 'Overflow: input needs wider integers to process',\n  'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n  'invalid-input': 'Invalid input'\n};\n/** Convenience shortcuts */\n\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n/*--------------------------------------------------------------------------*/\n\n/**\r\n * A generic error utility function.\r\n * @private\r\n * @param {String} type The error type.\r\n * @returns {Error} Throws a `RangeError` with the applicable error message.\r\n */\n\nfunction error(type) {\n  throw new RangeError(errors[type]);\n}\n/**\r\n * A generic `Array#map` utility function.\r\n * @private\r\n * @param {Array} array The array to iterate over.\r\n * @param {Function} callback The function that gets called for every array\r\n * item.\r\n * @returns {Array} A new array of values returned by the callback function.\r\n */\n\n\nfunction map(array, fn) {\n  const result = [];\n  let length = array.length;\n\n  while (length--) {\n    result[length] = fn(array[length]);\n  }\n\n  return result;\n}\n/**\r\n * A simple `Array#map`-like wrapper to work with domain name strings or email\r\n * addresses.\r\n * @private\r\n * @param {String} domain The domain name or email address.\r\n * @param {Function} callback The function that gets called for every\r\n * character.\r\n * @returns {Array} A new string of characters returned by the callback\r\n * function.\r\n */\n\n\nfunction mapDomain(string, fn) {\n  const parts = string.split('@');\n  let result = '';\n\n  if (parts.length > 1) {\n    // In email addresses, only the domain name should be punycoded. Leave\n    // the local part (i.e. everything up to `@`) intact.\n    result = parts[0] + '@';\n    string = parts[1];\n  } // Avoid `split(regex)` for IE8 compatibility. See #17.\n\n\n  string = string.replace(regexSeparators, '\\x2E');\n  const labels = string.split('.');\n  const encoded = map(labels, fn).join('.');\n  return result + encoded;\n}\n/**\r\n * Creates an array containing the numeric code points of each Unicode\r\n * character in the string. While JavaScript uses UCS-2 internally,\r\n * this function will convert a pair of surrogate halves (each of which\r\n * UCS-2 exposes as separate characters) into a single code point,\r\n * matching UTF-16.\r\n * @see `punycode.ucs2.encode`\r\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n * @memberOf punycode.ucs2\r\n * @name decode\r\n * @param {String} string The Unicode input string (UCS-2).\r\n * @returns {Array} The new array of code points.\r\n */\n\n\nfunction ucs2decode(string) {\n  const output = [];\n  let counter = 0;\n  const length = string.length;\n\n  while (counter < length) {\n    const value = string.charCodeAt(counter++);\n\n    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n      // It's a high surrogate, and there is a next character.\n      const extra = string.charCodeAt(counter++);\n\n      if ((extra & 0xFC00) == 0xDC00) {\n        // Low surrogate.\n        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n      } else {\n        // It's an unmatched surrogate; only append this code unit, in case the\n        // next code unit is the high surrogate of a surrogate pair.\n        output.push(value);\n        counter--;\n      }\n    } else {\n      output.push(value);\n    }\n  }\n\n  return output;\n}\n/**\r\n * Creates a string based on an array of numeric code points.\r\n * @see `punycode.ucs2.decode`\r\n * @memberOf punycode.ucs2\r\n * @name encode\r\n * @param {Array} codePoints The array of numeric code points.\r\n * @returns {String} The new Unicode string (UCS-2).\r\n */\n\n\nconst ucs2encode = array => String.fromCodePoint(...array);\n/**\r\n * Converts a basic code point into a digit/integer.\r\n * @see `digitToBasic()`\r\n * @private\r\n * @param {Number} codePoint The basic numeric code point value.\r\n * @returns {Number} The numeric value of a basic code point (for use in\r\n * representing integers) in the range `0` to `base - 1`, or `base` if\r\n * the code point does not represent a value.\r\n */\n\n\nconst basicToDigit = function (codePoint) {\n  if (codePoint - 0x30 < 0x0A) {\n    return codePoint - 0x16;\n  }\n\n  if (codePoint - 0x41 < 0x1A) {\n    return codePoint - 0x41;\n  }\n\n  if (codePoint - 0x61 < 0x1A) {\n    return codePoint - 0x61;\n  }\n\n  return base;\n};\n/**\r\n * Converts a digit/integer into a basic code point.\r\n * @see `basicToDigit()`\r\n * @private\r\n * @param {Number} digit The numeric value of a basic code point.\r\n * @returns {Number} The basic code point whose value (when used for\r\n * representing integers) is `digit`, which needs to be in the range\r\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\r\n * used; else, the lowercase form is used. The behavior is undefined\r\n * if `flag` is non-zero and `digit` has no uppercase form.\r\n */\n\n\nconst digitToBasic = function (digit, flag) {\n  //  0..25 map to ASCII a..z or A..Z\n  // 26..35 map to ASCII 0..9\n  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n/**\r\n * Bias adaptation function as per section 3.4 of RFC 3492.\r\n * https://tools.ietf.org/html/rfc3492#section-3.4\r\n * @private\r\n */\n\n\nconst adapt = function (delta, numPoints, firstTime) {\n  let k = 0;\n  delta = firstTime ? floor(delta / damp) : delta >> 1;\n  delta += floor(delta / numPoints);\n\n  for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n    delta = floor(delta / baseMinusTMin);\n  }\n\n  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n/**\r\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\r\n * symbols.\r\n * @memberOf punycode\r\n * @param {String} input The Punycode string of ASCII-only symbols.\r\n * @returns {String} The resulting string of Unicode symbols.\r\n */\n\n\nconst decode = function (input) {\n  // Don't use UCS-2.\n  const output = [];\n  const inputLength = input.length;\n  let i = 0;\n  let n = initialN;\n  let bias = initialBias; // Handle the basic code points: let `basic` be the number of input code\n  // points before the last delimiter, or `0` if there is none, then copy\n  // the first basic code points to the output.\n\n  let basic = input.lastIndexOf(delimiter);\n\n  if (basic < 0) {\n    basic = 0;\n  }\n\n  for (let j = 0; j < basic; ++j) {\n    // if it's not a basic code point\n    if (input.charCodeAt(j) >= 0x80) {\n      error('not-basic');\n    }\n\n    output.push(input.charCodeAt(j));\n  } // Main decoding loop: start just after the last delimiter if any basic code\n  // points were copied; start at the beginning otherwise.\n\n\n  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength;) {\n    // `index` is the index of the next character to be consumed.\n    // Decode a generalized variable-length integer into `delta`,\n    // which gets added to `i`. The overflow checking is easier\n    // if we increase `i` as we go, then subtract off its starting\n    // value at the end to obtain `delta`.\n    let oldi = i;\n\n    for (let w = 1, k = base;; k += base) {\n      if (index >= inputLength) {\n        error('invalid-input');\n      }\n\n      const digit = basicToDigit(input.charCodeAt(index++));\n\n      if (digit >= base || digit > floor((maxInt - i) / w)) {\n        error('overflow');\n      }\n\n      i += digit * w;\n      const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n      if (digit < t) {\n        break;\n      }\n\n      const baseMinusT = base - t;\n\n      if (w > floor(maxInt / baseMinusT)) {\n        error('overflow');\n      }\n\n      w *= baseMinusT;\n    }\n\n    const out = output.length + 1;\n    bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,\n    // incrementing `n` each time, so we'll fix that now:\n\n    if (floor(i / out) > maxInt - n) {\n      error('overflow');\n    }\n\n    n += floor(i / out);\n    i %= out; // Insert `n` at position `i` of the output.\n\n    output.splice(i++, 0, n);\n  }\n\n  return String.fromCodePoint(...output);\n};\n/**\r\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\r\n * Punycode string of ASCII-only symbols.\r\n * @memberOf punycode\r\n * @param {String} input The string of Unicode symbols.\r\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\r\n */\n\n\nconst encode = function (input) {\n  const output = []; // Convert the input in UCS-2 to an array of Unicode code points.\n\n  input = ucs2decode(input); // Cache the length.\n\n  let inputLength = input.length; // Initialize the state.\n\n  let n = initialN;\n  let delta = 0;\n  let bias = initialBias; // Handle the basic code points.\n\n  for (const currentValue of input) {\n    if (currentValue < 0x80) {\n      output.push(stringFromCharCode(currentValue));\n    }\n  }\n\n  let basicLength = output.length;\n  let handledCPCount = basicLength; // `handledCPCount` is the number of code points that have been handled;\n  // `basicLength` is the number of basic code points.\n  // Finish the basic string with a delimiter unless it's empty.\n\n  if (basicLength) {\n    output.push(delimiter);\n  } // Main encoding loop:\n\n\n  while (handledCPCount < inputLength) {\n    // All non-basic code points < n have been handled already. Find the next\n    // larger one:\n    let m = maxInt;\n\n    for (const currentValue of input) {\n      if (currentValue >= n && currentValue < m) {\n        m = currentValue;\n      }\n    } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n    // but guard against overflow.\n\n\n    const handledCPCountPlusOne = handledCPCount + 1;\n\n    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n      error('overflow');\n    }\n\n    delta += (m - n) * handledCPCountPlusOne;\n    n = m;\n\n    for (const currentValue of input) {\n      if (currentValue < n && ++delta > maxInt) {\n        error('overflow');\n      }\n\n      if (currentValue == n) {\n        // Represent delta as a generalized variable-length integer.\n        let q = delta;\n\n        for (let k = base;; k += base) {\n          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n          if (q < t) {\n            break;\n          }\n\n          const qMinusT = q - t;\n          const baseMinusT = base - t;\n          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n          q = floor(qMinusT / baseMinusT);\n        }\n\n        output.push(stringFromCharCode(digitToBasic(q, 0)));\n        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n        delta = 0;\n        ++handledCPCount;\n      }\n    }\n\n    ++delta;\n    ++n;\n  }\n\n  return output.join('');\n};\n/**\r\n * Converts a Punycode string representing a domain name or an email address\r\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\r\n * it doesn't matter if you call it on a string that has already been\r\n * converted to Unicode.\r\n * @memberOf punycode\r\n * @param {String} input The Punycoded domain name or email address to\r\n * convert to Unicode.\r\n * @returns {String} The Unicode representation of the given Punycode\r\n * string.\r\n */\n\n\nconst toUnicode = function (input) {\n  return mapDomain(input, function (string) {\n    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n  });\n};\n/**\r\n * Converts a Unicode string representing a domain name or an email address to\r\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\r\n * i.e. it doesn't matter if you call it with a domain that's already in\r\n * ASCII.\r\n * @memberOf punycode\r\n * @param {String} input The domain name or email address to convert, as a\r\n * Unicode string.\r\n * @returns {String} The Punycode representation of the given domain name or\r\n * email address.\r\n */\n\n\nconst toASCII = function (input) {\n  return mapDomain(input, function (string) {\n    return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n  });\n};\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\n\n\nconst punycode = {\n  /**\r\n   * A string representing the current Punycode.js version number.\r\n   * @memberOf punycode\r\n   * @type String\r\n   */\n  'version': '2.1.0',\n\n  /**\r\n   * An object of methods to convert from JavaScript's internal character\r\n   * representation (UCS-2) to Unicode code points, and back.\r\n   * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n   * @memberOf punycode\r\n   * @type Object\r\n   */\n  'ucs2': {\n    'decode': ucs2decode,\n    'encode': ucs2encode\n  },\n  'decode': decode,\n  'encode': encode,\n  'toASCII': toASCII,\n  'toUnicode': toUnicode\n};\nexport { ucs2decode, ucs2encode, decode, encode, toASCII, toUnicode };\nexport default punycode;","map":{"version":3,"names":["maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","baseMinusTMin","floor","Math","stringFromCharCode","String","fromCharCode","error","type","RangeError","map","array","fn","result","length","mapDomain","string","parts","split","replace","labels","encoded","join","ucs2decode","output","counter","value","charCodeAt","extra","push","ucs2encode","fromCodePoint","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","decode","input","inputLength","i","n","bias","basic","lastIndexOf","j","index","oldi","w","t","baseMinusT","out","splice","encode","currentValue","basicLength","handledCPCount","m","handledCPCountPlusOne","q","qMinusT","toUnicode","test","slice","toLowerCase","toASCII","punycode"],"sources":["C:/Users/hp/Desktop/javascript/Major Project/Complaint-Management-System-1/node_modules/punycode/punycode.es6.js"],"sourcesContent":["'use strict';\r\n\r\n/** Highest positive signed 32-bit float value */\r\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\r\n\r\n/** Bootstring parameters */\r\nconst base = 36;\r\nconst tMin = 1;\r\nconst tMax = 26;\r\nconst skew = 38;\r\nconst damp = 700;\r\nconst initialBias = 72;\r\nconst initialN = 128; // 0x80\r\nconst delimiter = '-'; // '\\x2D'\r\n\r\n/** Regular expressions */\r\nconst regexPunycode = /^xn--/;\r\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\r\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\r\n\r\n/** Error messages */\r\nconst errors = {\r\n\t'overflow': 'Overflow: input needs wider integers to process',\r\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\r\n\t'invalid-input': 'Invalid input'\r\n};\r\n\r\n/** Convenience shortcuts */\r\nconst baseMinusTMin = base - tMin;\r\nconst floor = Math.floor;\r\nconst stringFromCharCode = String.fromCharCode;\r\n\r\n/*--------------------------------------------------------------------------*/\r\n\r\n/**\r\n * A generic error utility function.\r\n * @private\r\n * @param {String} type The error type.\r\n * @returns {Error} Throws a `RangeError` with the applicable error message.\r\n */\r\nfunction error(type) {\r\n\tthrow new RangeError(errors[type]);\r\n}\r\n\r\n/**\r\n * A generic `Array#map` utility function.\r\n * @private\r\n * @param {Array} array The array to iterate over.\r\n * @param {Function} callback The function that gets called for every array\r\n * item.\r\n * @returns {Array} A new array of values returned by the callback function.\r\n */\r\nfunction map(array, fn) {\r\n\tconst result = [];\r\n\tlet length = array.length;\r\n\twhile (length--) {\r\n\t\tresult[length] = fn(array[length]);\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * A simple `Array#map`-like wrapper to work with domain name strings or email\r\n * addresses.\r\n * @private\r\n * @param {String} domain The domain name or email address.\r\n * @param {Function} callback The function that gets called for every\r\n * character.\r\n * @returns {Array} A new string of characters returned by the callback\r\n * function.\r\n */\r\nfunction mapDomain(string, fn) {\r\n\tconst parts = string.split('@');\r\n\tlet result = '';\r\n\tif (parts.length > 1) {\r\n\t\t// In email addresses, only the domain name should be punycoded. Leave\r\n\t\t// the local part (i.e. everything up to `@`) intact.\r\n\t\tresult = parts[0] + '@';\r\n\t\tstring = parts[1];\r\n\t}\r\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\r\n\tstring = string.replace(regexSeparators, '\\x2E');\r\n\tconst labels = string.split('.');\r\n\tconst encoded = map(labels, fn).join('.');\r\n\treturn result + encoded;\r\n}\r\n\r\n/**\r\n * Creates an array containing the numeric code points of each Unicode\r\n * character in the string. While JavaScript uses UCS-2 internally,\r\n * this function will convert a pair of surrogate halves (each of which\r\n * UCS-2 exposes as separate characters) into a single code point,\r\n * matching UTF-16.\r\n * @see `punycode.ucs2.encode`\r\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n * @memberOf punycode.ucs2\r\n * @name decode\r\n * @param {String} string The Unicode input string (UCS-2).\r\n * @returns {Array} The new array of code points.\r\n */\r\nfunction ucs2decode(string) {\r\n\tconst output = [];\r\n\tlet counter = 0;\r\n\tconst length = string.length;\r\n\twhile (counter < length) {\r\n\t\tconst value = string.charCodeAt(counter++);\r\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\r\n\t\t\t// It's a high surrogate, and there is a next character.\r\n\t\t\tconst extra = string.charCodeAt(counter++);\r\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\r\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\r\n\t\t\t} else {\r\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\r\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\r\n\t\t\t\toutput.push(value);\r\n\t\t\t\tcounter--;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\toutput.push(value);\r\n\t\t}\r\n\t}\r\n\treturn output;\r\n}\r\n\r\n/**\r\n * Creates a string based on an array of numeric code points.\r\n * @see `punycode.ucs2.decode`\r\n * @memberOf punycode.ucs2\r\n * @name encode\r\n * @param {Array} codePoints The array of numeric code points.\r\n * @returns {String} The new Unicode string (UCS-2).\r\n */\r\nconst ucs2encode = array => String.fromCodePoint(...array);\r\n\r\n/**\r\n * Converts a basic code point into a digit/integer.\r\n * @see `digitToBasic()`\r\n * @private\r\n * @param {Number} codePoint The basic numeric code point value.\r\n * @returns {Number} The numeric value of a basic code point (for use in\r\n * representing integers) in the range `0` to `base - 1`, or `base` if\r\n * the code point does not represent a value.\r\n */\r\nconst basicToDigit = function(codePoint) {\r\n\tif (codePoint - 0x30 < 0x0A) {\r\n\t\treturn codePoint - 0x16;\r\n\t}\r\n\tif (codePoint - 0x41 < 0x1A) {\r\n\t\treturn codePoint - 0x41;\r\n\t}\r\n\tif (codePoint - 0x61 < 0x1A) {\r\n\t\treturn codePoint - 0x61;\r\n\t}\r\n\treturn base;\r\n};\r\n\r\n/**\r\n * Converts a digit/integer into a basic code point.\r\n * @see `basicToDigit()`\r\n * @private\r\n * @param {Number} digit The numeric value of a basic code point.\r\n * @returns {Number} The basic code point whose value (when used for\r\n * representing integers) is `digit`, which needs to be in the range\r\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\r\n * used; else, the lowercase form is used. The behavior is undefined\r\n * if `flag` is non-zero and `digit` has no uppercase form.\r\n */\r\nconst digitToBasic = function(digit, flag) {\r\n\t//  0..25 map to ASCII a..z or A..Z\r\n\t// 26..35 map to ASCII 0..9\r\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\r\n};\r\n\r\n/**\r\n * Bias adaptation function as per section 3.4 of RFC 3492.\r\n * https://tools.ietf.org/html/rfc3492#section-3.4\r\n * @private\r\n */\r\nconst adapt = function(delta, numPoints, firstTime) {\r\n\tlet k = 0;\r\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\r\n\tdelta += floor(delta / numPoints);\r\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\r\n\t\tdelta = floor(delta / baseMinusTMin);\r\n\t}\r\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\r\n};\r\n\r\n/**\r\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\r\n * symbols.\r\n * @memberOf punycode\r\n * @param {String} input The Punycode string of ASCII-only symbols.\r\n * @returns {String} The resulting string of Unicode symbols.\r\n */\r\nconst decode = function(input) {\r\n\t// Don't use UCS-2.\r\n\tconst output = [];\r\n\tconst inputLength = input.length;\r\n\tlet i = 0;\r\n\tlet n = initialN;\r\n\tlet bias = initialBias;\r\n\r\n\t// Handle the basic code points: let `basic` be the number of input code\r\n\t// points before the last delimiter, or `0` if there is none, then copy\r\n\t// the first basic code points to the output.\r\n\r\n\tlet basic = input.lastIndexOf(delimiter);\r\n\tif (basic < 0) {\r\n\t\tbasic = 0;\r\n\t}\r\n\r\n\tfor (let j = 0; j < basic; ++j) {\r\n\t\t// if it's not a basic code point\r\n\t\tif (input.charCodeAt(j) >= 0x80) {\r\n\t\t\terror('not-basic');\r\n\t\t}\r\n\t\toutput.push(input.charCodeAt(j));\r\n\t}\r\n\r\n\t// Main decoding loop: start just after the last delimiter if any basic code\r\n\t// points were copied; start at the beginning otherwise.\r\n\r\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\r\n\r\n\t\t// `index` is the index of the next character to be consumed.\r\n\t\t// Decode a generalized variable-length integer into `delta`,\r\n\t\t// which gets added to `i`. The overflow checking is easier\r\n\t\t// if we increase `i` as we go, then subtract off its starting\r\n\t\t// value at the end to obtain `delta`.\r\n\t\tlet oldi = i;\r\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\r\n\r\n\t\t\tif (index >= inputLength) {\r\n\t\t\t\terror('invalid-input');\r\n\t\t\t}\r\n\r\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\r\n\r\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\r\n\t\t\ti += digit * w;\r\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n\r\n\t\t\tif (digit < t) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tconst baseMinusT = base - t;\r\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\r\n\t\t\tw *= baseMinusT;\r\n\r\n\t\t}\r\n\r\n\t\tconst out = output.length + 1;\r\n\t\tbias = adapt(i - oldi, out, oldi == 0);\r\n\r\n\t\t// `i` was supposed to wrap around from `out` to `0`,\r\n\t\t// incrementing `n` each time, so we'll fix that now:\r\n\t\tif (floor(i / out) > maxInt - n) {\r\n\t\t\terror('overflow');\r\n\t\t}\r\n\r\n\t\tn += floor(i / out);\r\n\t\ti %= out;\r\n\r\n\t\t// Insert `n` at position `i` of the output.\r\n\t\toutput.splice(i++, 0, n);\r\n\r\n\t}\r\n\r\n\treturn String.fromCodePoint(...output);\r\n};\r\n\r\n/**\r\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\r\n * Punycode string of ASCII-only symbols.\r\n * @memberOf punycode\r\n * @param {String} input The string of Unicode symbols.\r\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\r\n */\r\nconst encode = function(input) {\r\n\tconst output = [];\r\n\r\n\t// Convert the input in UCS-2 to an array of Unicode code points.\r\n\tinput = ucs2decode(input);\r\n\r\n\t// Cache the length.\r\n\tlet inputLength = input.length;\r\n\r\n\t// Initialize the state.\r\n\tlet n = initialN;\r\n\tlet delta = 0;\r\n\tlet bias = initialBias;\r\n\r\n\t// Handle the basic code points.\r\n\tfor (const currentValue of input) {\r\n\t\tif (currentValue < 0x80) {\r\n\t\t\toutput.push(stringFromCharCode(currentValue));\r\n\t\t}\r\n\t}\r\n\r\n\tlet basicLength = output.length;\r\n\tlet handledCPCount = basicLength;\r\n\r\n\t// `handledCPCount` is the number of code points that have been handled;\r\n\t// `basicLength` is the number of basic code points.\r\n\r\n\t// Finish the basic string with a delimiter unless it's empty.\r\n\tif (basicLength) {\r\n\t\toutput.push(delimiter);\r\n\t}\r\n\r\n\t// Main encoding loop:\r\n\twhile (handledCPCount < inputLength) {\r\n\r\n\t\t// All non-basic code points < n have been handled already. Find the next\r\n\t\t// larger one:\r\n\t\tlet m = maxInt;\r\n\t\tfor (const currentValue of input) {\r\n\t\t\tif (currentValue >= n && currentValue < m) {\r\n\t\t\t\tm = currentValue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\r\n\t\t// but guard against overflow.\r\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\r\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\r\n\t\t\terror('overflow');\r\n\t\t}\r\n\r\n\t\tdelta += (m - n) * handledCPCountPlusOne;\r\n\t\tn = m;\r\n\r\n\t\tfor (const currentValue of input) {\r\n\t\t\tif (currentValue < n && ++delta > maxInt) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\t\t\tif (currentValue == n) {\r\n\t\t\t\t// Represent delta as a generalized variable-length integer.\r\n\t\t\t\tlet q = delta;\r\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\r\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n\t\t\t\t\tif (q < t) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst qMinusT = q - t;\r\n\t\t\t\t\tconst baseMinusT = base - t;\r\n\t\t\t\t\toutput.push(\r\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\r\n\t\t\t\t\t);\r\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\r\n\t\t\t\t}\r\n\r\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\r\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\r\n\t\t\t\tdelta = 0;\r\n\t\t\t\t++handledCPCount;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t++delta;\r\n\t\t++n;\r\n\r\n\t}\r\n\treturn output.join('');\r\n};\r\n\r\n/**\r\n * Converts a Punycode string representing a domain name or an email address\r\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\r\n * it doesn't matter if you call it on a string that has already been\r\n * converted to Unicode.\r\n * @memberOf punycode\r\n * @param {String} input The Punycoded domain name or email address to\r\n * convert to Unicode.\r\n * @returns {String} The Unicode representation of the given Punycode\r\n * string.\r\n */\r\nconst toUnicode = function(input) {\r\n\treturn mapDomain(input, function(string) {\r\n\t\treturn regexPunycode.test(string)\r\n\t\t\t? decode(string.slice(4).toLowerCase())\r\n\t\t\t: string;\r\n\t});\r\n};\r\n\r\n/**\r\n * Converts a Unicode string representing a domain name or an email address to\r\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\r\n * i.e. it doesn't matter if you call it with a domain that's already in\r\n * ASCII.\r\n * @memberOf punycode\r\n * @param {String} input The domain name or email address to convert, as a\r\n * Unicode string.\r\n * @returns {String} The Punycode representation of the given domain name or\r\n * email address.\r\n */\r\nconst toASCII = function(input) {\r\n\treturn mapDomain(input, function(string) {\r\n\t\treturn regexNonASCII.test(string)\r\n\t\t\t? 'xn--' + encode(string)\r\n\t\t\t: string;\r\n\t});\r\n};\r\n\r\n/*--------------------------------------------------------------------------*/\r\n\r\n/** Define the public API */\r\nconst punycode = {\r\n\t/**\r\n\t * A string representing the current Punycode.js version number.\r\n\t * @memberOf punycode\r\n\t * @type String\r\n\t */\r\n\t'version': '2.1.0',\r\n\t/**\r\n\t * An object of methods to convert from JavaScript's internal character\r\n\t * representation (UCS-2) to Unicode code points, and back.\r\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n\t * @memberOf punycode\r\n\t * @type Object\r\n\t */\r\n\t'ucs2': {\r\n\t\t'decode': ucs2decode,\r\n\t\t'encode': ucs2encode\r\n\t},\r\n\t'decode': decode,\r\n\t'encode': encode,\r\n\t'toASCII': toASCII,\r\n\t'toUnicode': toUnicode\r\n};\r\n\r\nexport { ucs2decode, ucs2encode, decode, encode, toASCII, toUnicode };\r\nexport default punycode;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}