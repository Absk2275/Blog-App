{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.concurrently = void 0;\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nconst spawn_command_1 = __importDefault(require(\"spawn-command\"));\n\nconst tree_kill_1 = __importDefault(require(\"tree-kill\"));\n\nconst command_1 = require(\"./command\");\n\nconst expand_arguments_1 = require(\"./command-parser/expand-arguments\");\n\nconst expand_npm_shortcut_1 = require(\"./command-parser/expand-npm-shortcut\");\n\nconst expand_npm_wildcard_1 = require(\"./command-parser/expand-npm-wildcard\");\n\nconst strip_quotes_1 = require(\"./command-parser/strip-quotes\");\n\nconst completion_listener_1 = require(\"./completion-listener\");\n\nconst get_spawn_opts_1 = require(\"./get-spawn-opts\");\n\nconst output_writer_1 = require(\"./output-writer\");\n\nconst defaults = {\n  spawn: spawn_command_1.default,\n  kill: tree_kill_1.default,\n  raw: false,\n  controllers: [],\n  cwd: undefined\n};\n/**\n * Core concurrently functionality -- spawns the given commands concurrently and\n * returns the commands themselves + the result according to the specified success condition.\n *\n * @see CompletionListener\n */\n\nfunction concurrently(baseCommands, baseOptions) {\n  assert_1.default.ok(Array.isArray(baseCommands), '[concurrently] commands should be an array');\n  assert_1.default.notStrictEqual(baseCommands.length, 0, '[concurrently] no commands provided');\n  const options = lodash_1.default.defaults(baseOptions, defaults);\n  const commandParsers = [new strip_quotes_1.StripQuotes(), new expand_npm_shortcut_1.ExpandNpmShortcut(), new expand_npm_wildcard_1.ExpandNpmWildcard()];\n\n  if (options.additionalArguments) {\n    commandParsers.push(new expand_arguments_1.ExpandArguments(options.additionalArguments));\n  }\n\n  let lastColor = '';\n  let commands = (0, lodash_1.default)(baseCommands).map(mapToCommandInfo).flatMap(command => parseCommand(command, commandParsers)).map((command, index) => {\n    // Use documented behaviour of repeating last color when specifying more commands than colors\n    lastColor = options.prefixColors && options.prefixColors[index] || lastColor;\n    return new command_1.Command(Object.assign({\n      index,\n      prefixColor: lastColor\n    }, command), (0, get_spawn_opts_1.getSpawnOpts)({\n      raw: options.raw,\n      env: command.env,\n      cwd: command.cwd || options.cwd\n    }), options.spawn, options.kill);\n  }).value();\n  const handleResult = options.controllers.reduce((_ref, controller) => {\n    let {\n      commands: prevCommands,\n      onFinishCallbacks\n    } = _ref;\n    const {\n      commands,\n      onFinish\n    } = controller.handle(prevCommands);\n    return {\n      commands,\n      onFinishCallbacks: lodash_1.default.concat(onFinishCallbacks, onFinish ? [onFinish] : [])\n    };\n  }, {\n    commands,\n    onFinishCallbacks: []\n  });\n  commands = handleResult.commands;\n\n  if (options.logger) {\n    const outputWriter = new output_writer_1.OutputWriter({\n      outputStream: options.outputStream,\n      group: options.group,\n      commands\n    });\n    options.logger.output.subscribe(_ref2 => {\n      let {\n        command,\n        text\n      } = _ref2;\n      return outputWriter.write(command, text);\n    });\n  }\n\n  const commandsLeft = commands.slice();\n  const maxProcesses = Math.max(1, Number(options.maxProcesses) || commandsLeft.length);\n\n  for (let i = 0; i < maxProcesses; i++) {\n    maybeRunMore(commandsLeft);\n  }\n\n  const result = new completion_listener_1.CompletionListener({\n    successCondition: options.successCondition\n  }).listen(commands).finally(() => {\n    handleResult.onFinishCallbacks.forEach(onFinish => onFinish());\n  });\n  return {\n    result,\n    commands\n  };\n}\n\nexports.concurrently = concurrently;\n;\n\nfunction mapToCommandInfo(command) {\n  if (typeof command === 'string') {\n    return {\n      command,\n      name: '',\n      env: {},\n      cwd: ''\n    };\n  }\n\n  return Object.assign({\n    command: command.command,\n    name: command.name || '',\n    env: command.env || {},\n    cwd: command.cwd || ''\n  }, command.prefixColor ? {\n    prefixColor: command.prefixColor\n  } : {});\n}\n\nfunction parseCommand(command, parsers) {\n  return parsers.reduce((commands, parser) => lodash_1.default.flatMap(commands, command => parser.parse(command)), lodash_1.default.castArray(command));\n}\n\nfunction maybeRunMore(commandsLeft) {\n  const command = commandsLeft.shift();\n\n  if (!command) {\n    return;\n  }\n\n  command.start();\n  command.close.subscribe(() => {\n    maybeRunMore(commandsLeft);\n  });\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","concurrently","assert_1","require","lodash_1","spawn_command_1","tree_kill_1","command_1","expand_arguments_1","expand_npm_shortcut_1","expand_npm_wildcard_1","strip_quotes_1","completion_listener_1","get_spawn_opts_1","output_writer_1","defaults","spawn","default","kill","raw","controllers","cwd","undefined","baseCommands","baseOptions","ok","Array","isArray","notStrictEqual","length","options","commandParsers","StripQuotes","ExpandNpmShortcut","ExpandNpmWildcard","additionalArguments","push","ExpandArguments","lastColor","commands","map","mapToCommandInfo","flatMap","command","parseCommand","index","prefixColors","Command","assign","prefixColor","getSpawnOpts","env","handleResult","reduce","controller","prevCommands","onFinishCallbacks","onFinish","handle","concat","logger","outputWriter","OutputWriter","outputStream","group","output","subscribe","text","write","commandsLeft","slice","maxProcesses","Math","max","Number","i","maybeRunMore","result","CompletionListener","successCondition","listen","finally","forEach","name","parsers","parser","parse","castArray","shift","start","close"],"sources":["C:/Users/Abhishek/Desktop/Complaint-Management/node_modules/concurrently/dist/src/concurrently.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.concurrently = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst lodash_1 = __importDefault(require(\"lodash\"));\nconst spawn_command_1 = __importDefault(require(\"spawn-command\"));\nconst tree_kill_1 = __importDefault(require(\"tree-kill\"));\nconst command_1 = require(\"./command\");\nconst expand_arguments_1 = require(\"./command-parser/expand-arguments\");\nconst expand_npm_shortcut_1 = require(\"./command-parser/expand-npm-shortcut\");\nconst expand_npm_wildcard_1 = require(\"./command-parser/expand-npm-wildcard\");\nconst strip_quotes_1 = require(\"./command-parser/strip-quotes\");\nconst completion_listener_1 = require(\"./completion-listener\");\nconst get_spawn_opts_1 = require(\"./get-spawn-opts\");\nconst output_writer_1 = require(\"./output-writer\");\nconst defaults = {\n    spawn: spawn_command_1.default,\n    kill: tree_kill_1.default,\n    raw: false,\n    controllers: [],\n    cwd: undefined,\n};\n/**\n * Core concurrently functionality -- spawns the given commands concurrently and\n * returns the commands themselves + the result according to the specified success condition.\n *\n * @see CompletionListener\n */\nfunction concurrently(baseCommands, baseOptions) {\n    assert_1.default.ok(Array.isArray(baseCommands), '[concurrently] commands should be an array');\n    assert_1.default.notStrictEqual(baseCommands.length, 0, '[concurrently] no commands provided');\n    const options = lodash_1.default.defaults(baseOptions, defaults);\n    const commandParsers = [\n        new strip_quotes_1.StripQuotes(),\n        new expand_npm_shortcut_1.ExpandNpmShortcut(),\n        new expand_npm_wildcard_1.ExpandNpmWildcard(),\n    ];\n    if (options.additionalArguments) {\n        commandParsers.push(new expand_arguments_1.ExpandArguments(options.additionalArguments));\n    }\n    let lastColor = '';\n    let commands = (0, lodash_1.default)(baseCommands)\n        .map(mapToCommandInfo)\n        .flatMap(command => parseCommand(command, commandParsers))\n        .map((command, index) => {\n        // Use documented behaviour of repeating last color when specifying more commands than colors\n        lastColor = options.prefixColors && options.prefixColors[index] || lastColor;\n        return new command_1.Command(Object.assign({\n            index,\n            prefixColor: lastColor,\n        }, command), (0, get_spawn_opts_1.getSpawnOpts)({\n            raw: options.raw,\n            env: command.env,\n            cwd: command.cwd || options.cwd,\n        }), options.spawn, options.kill);\n    })\n        .value();\n    const handleResult = options.controllers.reduce(({ commands: prevCommands, onFinishCallbacks }, controller) => {\n        const { commands, onFinish } = controller.handle(prevCommands);\n        return {\n            commands,\n            onFinishCallbacks: lodash_1.default.concat(onFinishCallbacks, onFinish ? [onFinish] : []),\n        };\n    }, { commands, onFinishCallbacks: [] });\n    commands = handleResult.commands;\n    if (options.logger) {\n        const outputWriter = new output_writer_1.OutputWriter({\n            outputStream: options.outputStream,\n            group: options.group,\n            commands,\n        });\n        options.logger.output.subscribe(({ command, text }) => outputWriter.write(command, text));\n    }\n    const commandsLeft = commands.slice();\n    const maxProcesses = Math.max(1, Number(options.maxProcesses) || commandsLeft.length);\n    for (let i = 0; i < maxProcesses; i++) {\n        maybeRunMore(commandsLeft);\n    }\n    const result = new completion_listener_1.CompletionListener({ successCondition: options.successCondition })\n        .listen(commands)\n        .finally(() => {\n        handleResult.onFinishCallbacks.forEach((onFinish) => onFinish());\n    });\n    return {\n        result,\n        commands,\n    };\n}\nexports.concurrently = concurrently;\n;\nfunction mapToCommandInfo(command) {\n    if (typeof command === 'string') {\n        return {\n            command,\n            name: '',\n            env: {},\n            cwd: '',\n        };\n    }\n    return Object.assign({\n        command: command.command,\n        name: command.name || '',\n        env: command.env || {},\n        cwd: command.cwd || '',\n    }, command.prefixColor ? {\n        prefixColor: command.prefixColor,\n    } : {});\n}\nfunction parseCommand(command, parsers) {\n    return parsers.reduce((commands, parser) => lodash_1.default.flatMap(commands, command => parser.parse(command)), lodash_1.default.castArray(command));\n}\nfunction maybeRunMore(commandsLeft) {\n    const command = commandsLeft.shift();\n    if (!command) {\n        return;\n    }\n    command.start();\n    command.close.subscribe(() => {\n        maybeRunMore(commandsLeft);\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}